// Decompiled by DJ v3.12.12.98 Copyright 2014 Atanas Neshkov  Date: 17/11/2017 7:06:57 p. m.
// Home Page: http://www.neshkov.com/dj.html - Check often for new version!
// Decompiler options: packimports(3) 
// Source File Name:   CMS.java

package co.com.andesscd.pki.clases;

import co.com.andesscd.*;
import co.com.pdf.text.DocumentException;
import co.com.pdf.text.Rectangle;
import co.com.pdf.text.pdf.*;
import co.com.pdf.text.pdf.security.CertificateInfo;
import co.org.bouncy.asn1.*;
import co.org.bouncy.asn1.cms.*;
import co.org.bouncy.asn1.tsp.MessageImprint;
import co.org.bouncy.asn1.tsp.TSTInfo;
import co.org.bouncy.asn1.x509.AlgorithmIdentifier;
import co.org.bouncy.cert.jcajce.JcaCertStore;
import co.org.bouncy.cert.jcajce.JcaCertStoreBuilder;
import co.org.bouncy.cert.selector.X509CertificateHolderSelector;
import co.org.bouncy.cert.selector.jcajce.JcaX509CertSelectorConverter;
import co.org.bouncy.cms.*;
import co.org.bouncy.cms.jcajce.JcaSignerInfoGeneratorBuilder;
import co.org.bouncy.cms.jcajce.JcaSimpleSignerInfoVerifierBuilder;
import co.org.bouncy.jce.provider.BouncyCastleProvider;
import co.org.bouncy.operator.ContentSigner;
import co.org.bouncy.operator.OperatorCreationException;
import co.org.bouncy.operator.jcajce.JcaContentSignerBuilder;
import co.org.bouncy.operator.jcajce.JcaDigestCalculatorProviderBuilder;
import co.org.bouncy.tsp.*;
import co.org.bouncy.util.Store;
import java.io.*;
import java.net.*;
import java.security.*;
import java.security.cert.*;
import java.util.*;
import java.util.concurrent.TimeUnit;
import org.apache.commons.io.FileUtils;
import sun.security.pkcs11.SunPKCS11;

// Referenced classes of package co.com.andesscd.pki.clases:
//            SNTPClient, TimeStamped, RESULTADO_VERIFICACION, TSAClient, 
//            ISignerWebService, OCSPClient, CRLClient

public class CMS
{
    private static final class TipoDocumento extends Enum
    {

        public static TipoDocumento[] values()
        {
            return (TipoDocumento[])$VALUES.clone();
        }

        public static TipoDocumento valueOf(String name)
        {
            return (TipoDocumento)Enum.valueOf(co/com/andesscd/pki/clases/CMS$TipoDocumento, name);
        }

        public static final TipoDocumento NO_ANALIZADO;
        public static final TipoDocumento DESCONOCIDO;
        public static final TipoDocumento PKCS7;
        public static final TipoDocumento PDF;
        public static final TipoDocumento PDF_FIRMADO;
        private static final TipoDocumento $VALUES[];

        static 
        {
            NO_ANALIZADO = new TipoDocumento("NO_ANALIZADO", 0);
            DESCONOCIDO = new TipoDocumento("DESCONOCIDO", 1);
            PKCS7 = new TipoDocumento("PKCS7", 2);
            PDF = new TipoDocumento("PDF", 3);
            PDF_FIRMADO = new TipoDocumento("PDF_FIRMADO", 4);
            $VALUES = (new TipoDocumento[] {
                NO_ANALIZADO, DESCONOCIDO, PKCS7, PDF, PDF_FIRMADO
            });
        }

        private TipoDocumento(String s, int i)
        {
            super(s, i);
        }
    }

    public static final class FuenteHoraria extends Enum
    {

        public static FuenteHoraria[] values()
        {
            return (FuenteHoraria[])$VALUES.clone();
        }

        public static FuenteHoraria valueOf(String name)
        {
            return (FuenteHoraria)Enum.valueOf(co/com/andesscd/pki/clases/CMS$FuenteHoraria, name);
        }

        public static final FuenteHoraria LOCAL;
        public static final FuenteHoraria SNTP;
        public static final FuenteHoraria TSA;
        private static final FuenteHoraria $VALUES[];

        static 
        {
            LOCAL = new FuenteHoraria("LOCAL", 0);
            SNTP = new FuenteHoraria("SNTP", 1);
            TSA = new FuenteHoraria("TSA", 2);
            $VALUES = (new FuenteHoraria[] {
                LOCAL, SNTP, TSA
            });
        }

        private FuenteHoraria(String s, int i)
        {
            super(s, i);
        }
    }


    public static void iniciarComponente()
    {
        Provider provider = Security.getProvider("BC");
        if(provider == null)
        {
            Security.addProvider(new BouncyCastleProvider());
            bcAgregado = true;
        }
    }

    private static void iniciarComponente(String xmlLicencia)
    {
        iniciarComponente();
        if(secureBlackboxIniciado);
    }

    private static void iniciarComponente(String xmlLicencia, String JNIPath)
    {
        iniciarComponente(xmlLicencia);
    }

    public static void setToleranciaTemporal(int toleranciaTemporal)
    {
        toleranciaTemporal = toleranciaTemporal;
    }

    public void setUrlOCSP(String url)
    {
        urlOCSP = url;
    }

    public void setUrlCRL(String url)
    {
        urlCRL = url;
    }

    public static int getToleranciaTemporal()
    {
        return toleranciaTemporal;
    }

    public static void setFirmaPdfVisible(boolean visible)
    {
        firmaPdfVisible = visible;
    }

    public static void setProxy(Proxy miProxy)
    {
        miProxy = miProxy;
    }

    public static void setProxy(String proxyUrl, int proxyPort, java.net.Proxy.Type type)
    {
        if(type == null)
            type = java.net.Proxy.Type.HTTP;
        if(proxyUrl != null && !"".equals(proxyUrl.trim()))
            miProxy = new Proxy(type, new InetSocketAddress(proxyUrl, proxyPort));
    }

    public static Proxy getProxy()
    {
        return miProxy;
    }

    public void setNombreDocumento(String nombreDocumento)
    {
        this.nombreDocumento = nombreDocumento;
    }

    public String getNombreDocumento()
    {
        return nombreDocumento;
    }

    public void setDescripcion(String descripcion)
    {
        this.descripcion = descripcion;
    }

    public static FuenteHoraria getFuenteHoraria()
    {
        return fuenteHoraria;
    }

    public static void setFuenteHorariaLocal()
    {
        urlFuenteHoraria = "";
        loginFuenteHoraria = "";
        passwordFuenteHoraria = "";
        fuenteHoraria = FuenteHoraria.LOCAL;
    }

    public static void setFuenteHorariaSNTP(String urlFuenteHoraria)
    {
        urlFuenteHoraria = urlFuenteHoraria;
        loginFuenteHoraria = "";
        passwordFuenteHoraria = "";
        fuenteHoraria = FuenteHoraria.SNTP;
    }

    public static void setFuenteHorariaTSA(String urlFuenteHoraria, String loginFuenteHoraria, String passwordFuenteHoraria)
    {
        urlFuenteHoraria = urlFuenteHoraria;
        loginFuenteHoraria = loginFuenteHoraria;
        passwordFuenteHoraria = passwordFuenteHoraria;
        fuenteHoraria = FuenteHoraria.TSA;
    }

    public static GregorianCalendar getFechaActual()
        throws IOException, NoSuchAlgorithmException, TSPException, CertificateException, Exception
    {
        GregorianCalendar fechaActual = null;
        static class _cls1
        {

            static final int $SwitchMap$co$com$andesscd$pki$clases$CMS$FuenteHoraria[];

            static 
            {
                $SwitchMap$co$com$andesscd$pki$clases$CMS$FuenteHoraria = new int[FuenteHoraria.values().length];
                try
                {
                    $SwitchMap$co$com$andesscd$pki$clases$CMS$FuenteHoraria[FuenteHoraria.LOCAL.ordinal()] = 1;
                }
                catch(NoSuchFieldError ex) { }
                try
                {
                    $SwitchMap$co$com$andesscd$pki$clases$CMS$FuenteHoraria[FuenteHoraria.SNTP.ordinal()] = 2;
                }
                catch(NoSuchFieldError ex) { }
                try
                {
                    $SwitchMap$co$com$andesscd$pki$clases$CMS$FuenteHoraria[FuenteHoraria.TSA.ordinal()] = 3;
                }
                catch(NoSuchFieldError ex) { }
            }
        }

        switch(_cls1..SwitchMap.co.com.andesscd.pki.clases.CMS.FuenteHoraria[fuenteHoraria.ordinal()])
        {
        case 1: // '\001'
            fechaActual = new GregorianCalendar(new SimpleTimeZone(0, "America/Bogota"));
            fechaActual.setTime(new Date());
            break;

        case 2: // '\002'
            SNTPClient sntpClient = new SNTPClient();
            sntpClient.requestTime(urlFuenteHoraria, 10000);
            fechaActual = sntpClient.getFecha();
            break;

        case 3: // '\003'
            Random r = new Random();
            byte datosAleatorios[] = new byte[8];
            r.nextBytes(datosAleatorios);
            ByteArrayOutputStream tokenStream = new ByteArrayOutputStream();
            TSAClient.getTimestampToken(new ByteArrayInputStream(datosAleatorios), urlFuenteHoraria, loginFuenteHoraria, passwordFuenteHoraria, tokenStream);
            TimeStamped timeStamped = new TimeStamped(tokenStream.toByteArray());
            fechaActual = timeStamped.getFechaEstampado();
            break;
        }
        return fechaActual;
    }

    private void iniciarCMS(InputStream streamEntrada)
        throws Exception
    {
        iniciarComponente();
        if(streamEntrada == null)
        {
            throw new Exception("No se proporcionaron datos de entrada");
        } else
        {
            contenido = Auxiliar.inputStream2ByteArray(streamEntrada);
            hashParaTimeStamp = new HashMap();
            return;
        }
    }

    public CMS(String archivoEntrada)
        throws FileNotFoundException, Exception
    {
        contenido = null;
        nombreDocumento = "";
        descripcion = "";
        tipoDocumento = TipoDocumento.NO_ANALIZADO;
        signedData = null;
        pdfReader = null;
        firmasPdf = null;
        urlOCSP = null;
        urlCRL = null;
        File archivo = new File(archivoEntrada);
        nombreDocumento = archivo.getName();
        descripcion = "";
        iniciarCMS(new FileInputStream(archivoEntrada));
    }

    public CMS(InputStream streamEntrada)
        throws Exception
    {
        contenido = null;
        nombreDocumento = "";
        descripcion = "";
        tipoDocumento = TipoDocumento.NO_ANALIZADO;
        signedData = null;
        pdfReader = null;
        firmasPdf = null;
        urlOCSP = null;
        urlCRL = null;
        nombreDocumento = "";
        descripcion = "";
        iniciarCMS(streamEntrada);
    }

    public CMS(URL url)
        throws IOException, Exception
    {
        contenido = null;
        nombreDocumento = "";
        descripcion = "";
        tipoDocumento = TipoDocumento.NO_ANALIZADO;
        signedData = null;
        pdfReader = null;
        firmasPdf = null;
        urlOCSP = null;
        urlCRL = null;
        HttpURLConnection conexion;
        if(getProxy() != null)
            conexion = (HttpURLConnection)url.openConnection(getProxy());
        else
            conexion = (HttpURLConnection)url.openConnection();
        nombreDocumento = "";
        descripcion = "";
        iniciarCMS(conexion.getInputStream());
    }

    public ArrayList getFirmasPdf()
        throws IllegalArgumentException, IOException, Exception
    {
        if(firmasPdf != null)
            return firmasPdf;
        firmasPdf = new ArrayList();
        try
        {
            if(pdfReader == null)
                pdfReader = new PdfReader(contenido);
        }
        catch(IOException ex)
        {
            throw new IllegalArgumentException("Los datos de entrada no describen un documento pdf valido");
        }
        AcroFields af = pdfReader.getAcroFields();
        ASN1Primitive pkcs;
        for(Iterator i$ = af.getSignatureNames().iterator(); i$.hasNext(); firmasPdf.add(new CMS(new ByteArrayInputStream(((ASN1Sequence)pkcs).getEncoded()))))
        {
            Object obj = i$.next();
            String name = (String)obj;
            af.getSignatureDictionary(name);
            PdfDictionary dict = af.getSignatureDictionary(name);
            PdfString contents = dict.getAsString(PdfName.CONTENTS);
            ASN1InputStream din = new ASN1InputStream(new ByteArrayInputStream(contents.getOriginalBytes()));
            try
            {
                pkcs = din.readObject();
            }
            catch(IOException e)
            {
                throw new IllegalArgumentException("No se puede decodificar la seccion del documento pdf que contiene la firma");
            }
            if(!(pkcs instanceof ASN1Sequence))
                throw new IllegalArgumentException("El formato de la firma en el documento pdf parace no ser valido");
        }

        return firmasPdf;
    }

    public TipoDocumento getTipoDocumento()
    {
        if(tipoDocumento == TipoDocumento.NO_ANALIZADO)
        {
            try
            {
                if(signedData == null)
                    decode(null);
                return tipoDocumento = TipoDocumento.PKCS7;
            }
            catch(Exception ex) { }
            try
            {
                if(pdfReader == null)
                    pdfReader = new PdfReader(contenido);
                tipoDocumento = TipoDocumento.PDF;
                if(!getFirmasPdf().isEmpty())
                    tipoDocumento = TipoDocumento.PDF_FIRMADO;
            }
            catch(Exception ex) { }
            if(tipoDocumento == TipoDocumento.NO_ANALIZADO)
                tipoDocumento = TipoDocumento.DESCONOCIDO;
        }
        return tipoDocumento;
    }

    public void decode(OutputStream streamSalida)
        throws IOException, CMSException, NoSuchAlgorithmException, NoSuchProviderException, GeneralSecurityException
    {
        if(signedData == null)
        {
            signedData = new CMSSignedData(contenido);
            firmantes = signedData.getSignerInfos();
            JcaCertStoreBuilder sb = new JcaCertStoreBuilder();
            sb.addCertificates(signedData.getCertificates());
            certificados = sb.build();
            ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
            signedData.getSignedContent().write(byteArrayOutputStream);
            salida = byteArrayOutputStream.toByteArray();
        }
        if(streamSalida != null)
            streamSalida.write(salida);
        if(streamSalida != null)
            streamSalida.close();
        break MISSING_BLOCK_LABEL_126;
        Exception exception;
        exception;
        if(streamSalida != null)
            streamSalida.close();
        throw exception;
    }

    private Collection getCertificados()
        throws CertStoreException
    {
        return certificados.getCertificates(null);
    }

    public void firmar(X509Certificate certificado, PrivateKey llavePrivada, Provider provedor, OutputStream streamSalida)
        throws NoSuchAlgorithmException, IOException, CMSException, CertStoreException, InvalidAlgorithmParameterException, CertificateEncodingException, OperatorCreationException, TSPException, Exception
    {
        CMSSignedDataGenerator generadorDeFirma;
        ArrayList listaDeCertificados;
        generadorDeFirma = new CMSSignedDataGenerator();
        listaDeCertificados = new ArrayList();
        listaDeCertificados.add(certificado);
        Store almacenDeCertificados = new JcaCertStore(listaDeCertificados);
        generadorDeFirma.addCertificates(almacenDeCertificados);
        JcaSignerInfoGeneratorBuilder jcaSignerInfoGeneratorBuilder = new JcaSignerInfoGeneratorBuilder((new JcaDigestCalculatorProviderBuilder()).setProvider("BC").build());
        ASN1EncodableVector signedAttributes = new ASN1EncodableVector();
        Date fechaActual = null;
        if(fuenteHoraria == FuenteHoraria.LOCAL || fuenteHoraria == FuenteHoraria.SNTP)
        {
            fechaActual = getFechaActual().getTime();
        } else
        {
            MessageDigest sha = MessageDigest.getInstance("SHA1");
            byte timeStampToken[] = TSAClient.getTimestampToken(sha.digest(contenido), urlFuenteHoraria, loginFuenteHoraria, passwordFuenteHoraria);
            fechaActual = (new TimeStamped(timeStampToken)).getFechaEstampado().getTime();
            ASN1EncodableVector unSignedAttributes = new ASN1EncodableVector();
            unSignedAttributes.add(new Attribute(new ASN1ObjectIdentifier(ID_TIME_STAMP_TOKEN), new DERSet((new ASN1InputStream(timeStampToken)).readObject())));
            AttributeTable unSignedAttributesTable = new AttributeTable(unSignedAttributes);
            SimpleAttributeTableGenerator unSignedAttributeGenerator = new SimpleAttributeTableGenerator(unSignedAttributesTable);
            jcaSignerInfoGeneratorBuilder.setUnsignedAttributeGenerator(unSignedAttributeGenerator);
        }
        signedAttributes.add(new Attribute(CMSAttributes.signingTime, new DERSet(new DERUTCTime(fechaActual))));
        AttributeTable signedAttributesTable = new AttributeTable(signedAttributes);
        DefaultSignedAttributeTableGenerator signedAttributeGenerator = new DefaultSignedAttributeTableGenerator(signedAttributesTable);
        jcaSignerInfoGeneratorBuilder.setSignedAttributeGenerator(signedAttributeGenerator);
        ContentSigner firmante = (new JcaContentSignerBuilder("SHA1withRSA")).setProvider(provedor).build(llavePrivada);
        SignerInfoGenerator signerInfoGenerator = jcaSignerInfoGeneratorBuilder.build(firmante, certificado);
        generadorDeFirma.addSignerInfoGenerator(signerInfoGenerator);
        ArrayList nuevosFirmantes = new ArrayList();
        CMSTypedData contenidoFirmable;
        Collection firmantesLocal;
        if(getTipoDocumento() == TipoDocumento.PKCS7)
        {
            ByteArrayOutputStream out = new ByteArrayOutputStream();
            decode(out);
            contenidoFirmable = new CMSProcessableByteArray(out.toByteArray());
            firmantesLocal = firmantes.getSigners();
            SignerInformation si;
            for(Iterator i$ = firmantesLocal.iterator(); i$.hasNext(); nuevosFirmantes.add(si))
                si = (SignerInformation)i$.next();

        } else
        {
            contenidoFirmable = new CMSProcessableByteArray(contenido);
        }
        CMSSignedData datosFirmados = generadorDeFirma.generate(contenidoFirmable, true);
        firmantesLocal = datosFirmados.getSignerInfos().getSigners();
        SignerInformation si;
        for(Iterator i$ = firmantesLocal.iterator(); i$.hasNext(); nuevosFirmantes.add(si))
            si = (SignerInformation)i$.next();

        SignerInformationStore newSignerInformationStore = new SignerInformationStore(nuevosFirmantes);
        CMSSignedData newSd = CMSSignedData.replaceSigners(datosFirmados, newSignerInformationStore);
        salida = newSd.getEncoded();
        streamSalida.write(salida);
        if(streamSalida != null)
            streamSalida.close();
        break MISSING_BLOCK_LABEL_575;
        Exception exception;
        exception;
        if(streamSalida != null)
            streamSalida.close();
        throw exception;
    }

    public void firmar(KeyStore keyStore, String alias, String contraseF1a, Provider provedor, OutputStream streamSalida)
        throws KeyStoreException, NoSuchAlgorithmException, UnrecoverableKeyException, Exception
    {
        if(!keyStore.containsAlias(alias))
            throw new Exception((new StringBuilder()).append("El almacen no contiene el alias: ").append(alias).toString());
        if(!keyStore.isKeyEntry(alias))
            throw new Exception((new StringBuilder()).append("El almacen no contiene una llave con alias: ").append(alias).toString());
        X509Certificate certificado = (X509Certificate)keyStore.getCertificate(alias);
        if(certificado == null)
            throw new Exception((new StringBuilder()).append("El almacen no contiene un certificado con alias: ").append(alias).toString());
        PrivateKey llavePrivada = (PrivateKey)keyStore.getKey(alias, contraseF1a == null ? null : contraseF1a.toCharArray());
        if(llavePrivada == null)
        {
            throw new Exception((new StringBuilder()).append("No se pudo recuperar la llave con alias: ").append(alias).toString());
        } else
        {
            firmar(certificado, llavePrivada, provedor, streamSalida);
            return;
        }
    }

    public void firmar(KeyStore keyStore, String alias, String contraseF1a, OutputStream streamSalida)
        throws NoSuchAlgorithmException, IOException, CMSException, CertStoreException, InvalidAlgorithmParameterException, CertificateEncodingException, OperatorCreationException, KeyStoreException, Exception
    {
        if(keyStore == null)
            if(OSValidador.getOS() == co.com.andesscd.OSValidador.OSTYPE.WINDOWS)
            {
                keyStore = KeyStore.getInstance("Windows-MY", "SunMSCAPI");
                keyStore.load(null, null);
            } else
            {
                keyStore = KeyStore.getInstance(KeyStore.getDefaultType());
                keyStore.load(new FileInputStream((new StringBuilder()).append(System.getProperty("java.home")).append("/lib/security/cacerts".replace('/', File.separatorChar)).toString()), "changeit".toCharArray());
            }
        firmar(keyStore, alias, contraseF1a, keyStore.getProvider(), streamSalida);
    }

    public void firmar(KeyStore keyStore, String contraseF1a, OutputStream streamSalida)
        throws KeyStoreException, NoSuchAlgorithmException, UnrecoverableKeyException, Exception
    {
        String alias = null;
        Enumeration aliases = keyStore.aliases();
        do
        {
            if(!aliases.hasMoreElements())
                break;
            alias = (String)aliases.nextElement();
        } while(!keyStore.isKeyEntry(alias));
        if(alias == null || alias.isEmpty())
        {
            throw new Exception("No se enocntro una llave util para firma dentro del contenedor");
        } else
        {
            firmar(keyStore, alias, contraseF1a, streamSalida);
            return;
        }
    }

    public static String firmar(String datos, String alias, String password)
        throws KeyStoreException, NoSuchProviderException, NoSuchAlgorithmException, CertificateException, IOException, Exception
    {
        ByteArrayOutputStream out = new ByteArrayOutputStream();
        KeyStore keystore;
        if(OSValidador.getOS() == co.com.andesscd.OSValidador.OSTYPE.WINDOWS)
        {
            keystore = KeyStore.getInstance("Windows-MY", "SunMSCAPI");
            keystore.load(null, null);
        } else
        {
            keystore = KeyStore.getInstance(KeyStore.getDefaultType());
            keystore.load(new FileInputStream((new StringBuilder()).append(System.getProperty("java.home")).append("/lib/security/cacerts".replace('/', File.separatorChar)).toString()), "changeit".toCharArray());
        }
        if(!keystore.containsAlias(alias))
        {
            throw new Exception((new StringBuilder()).append("El almacen de windows no contiene el alias ").append(alias).toString());
        } else
        {
            Certificate certificado = keystore.getCertificate(alias);
            java.security.Key privateKey = keystore.getKey(alias, password.toCharArray());
            CMS cms = new CMS(new ByteArrayInputStream(datos.getBytes("UTF-8")));
            cms.firmar((X509Certificate)certificado, (PrivateKey)privateKey, keystore.getProvider(), ((OutputStream) (out)));
            return new String(Base64Coder.encode(out.toByteArray()));
        }
    }

    public static byte[] getSha1(InputStream s)
        throws NoSuchAlgorithmException, IOException
    {
        MessageDigest messageDigest = MessageDigest.getInstance("SHA1");
        int read = 0;
        byte buff[] = new byte[0x100000];
        while((read = s.read(buff, 0, 0x100000)) > 0) 
            messageDigest.update(buff, 0, read);
        return messageDigest.digest();
    }

    public static String getVersion()
    {
        return "2.4.1.1";
    }

    public void addPdfMetaData(HashMap metaData)
    {
        pdfMetaData = metaData;
    }

    public void addPdfMetaData(String nombre, String valor)
    {
        if(pdfMetaData == null)
            pdfMetaData = new HashMap();
        pdfMetaData.put(nombre, valor);
    }

    public void setPdfMetaDataTitle(String titulo)
    {
        addPdfMetaData("Title", titulo);
    }

    public void setPdfMetaDataSubject(String asunto)
    {
        addPdfMetaData("Title", asunto);
    }

    public void setPdfMetaDataKeywords(String palabrasClave)
    {
        addPdfMetaData("Keywords", palabrasClave);
    }

    public void setPdfMetaDataCreator(String creador)
    {
        addPdfMetaData("Creator", creador);
    }

    public void setPdfMetaDataAuthor(String autor)
    {
        addPdfMetaData("Author", autor);
    }

    public void setPdfMetaDataCustom(String nombre, String valor)
    {
        addPdfMetaData(nombre, valor);
    }

    public PdfSignatureAppearance iniciarFirmaPdf(X509Certificate x509Certificate, OutputStream streamSalida)
        throws NoSuchAlgorithmException, TSPException, CertificateException, IOException, DocumentException, Exception
    {
        Calendar signDate = getFechaActual();
        PdfReader reader = new PdfReader(contenido);
        PdfStamper stamper = PdfStamper.createSignature(reader, streamSalida, '\0', null, true);
        if(pdfMetaData != null)
        {
            HashMap hMap = reader.getInfo();
            hMap.putAll(pdfMetaData);
            stamper.setMoreInfo(hMap);
        }
        PdfSignature pdfSignature = new PdfSignature(PdfName.ADOBE_PPKMS, PdfName.ADBE_PKCS7_SHA1);
        pdfSignature.setDate(new PdfDate(signDate));
        if(x509Certificate != null)
            pdfSignature.setName(CertificateInfo.getSubjectFields(x509Certificate).getField("CN"));
        PdfSignatureAppearance signatureAppearance = stamper.getSignatureAppearance();
        if(firmaPdfVisible)
            signatureAppearance.setVisibleSignature(new Rectangle(0.0F, 0.0F, 300F, 300F), reader.getNumberOfPages(), null);
        signatureAppearance.setSignDate(signDate);
        if(x509Certificate != null)
            signatureAppearance.setCertificate(x509Certificate);
        signatureAppearance.setCryptoDictionary(pdfSignature);
        HashMap exc = new HashMap();
        exc.put(PdfName.CONTENTS, Integer.valueOf(24002));
        if(x509Certificate != null);
        signatureAppearance.preClose(exc);
        return signatureAppearance;
    }

    public void finalizarFirmaPdf(X509Certificate x509Certificate, PdfSignatureAppearance signatureAppearance, byte firmaPlana[], OutputStream streamSalida)
        throws IOException, DocumentException, CMSException, CertStoreException, NoSuchProviderException, GeneralSecurityException, Exception
    {
        PdfDictionary pdfDictionary = new PdfDictionary();
        if(x509Certificate == null)
        {
            CMS cmdHashFirmado = new CMS(new ByteArrayInputStream(firmaPlana));
            cmdHashFirmado.decode(null);
            Collection certificadosUsados = cmdHashFirmado.certificados.getCertificates(null);
            Certificate certificado;
            for(Iterator i$ = certificadosUsados.iterator(); i$.hasNext(); signatureAppearance.setCertificate(certificado))
                certificado = (Certificate)i$.next();

        }
        byte outc[] = new byte[12000];
        System.arraycopy(firmaPlana, 0, outc, 0, firmaPlana.length);
        pdfDictionary.put(PdfName.CONTENTS, (new PdfString(outc)).setHexWriting(true));
        signatureAppearance.close(pdfDictionary);
        streamSalida.flush();
        streamSalida.close();
    }

    public void firmarPdf(X509Certificate x509Certificate, PrivateKey llavePrivada, Provider provedor, OutputStream streamSalida)
        throws InvalidAlgorithmParameterException, NoSuchAlgorithmException, IOException, DocumentException, CertStoreException, CMSException, Exception
    {
        PdfSignatureAppearance signatureAppearance = iniciarFirmaPdf(x509Certificate, streamSalida);
        CMS cmdHash = new CMS(new ByteArrayInputStream(getSha1(signatureAppearance.getRangeStream())));
        ByteArrayOutputStream streamHashFirmado = new ByteArrayOutputStream();
        cmdHash.firmar(x509Certificate, llavePrivada, provedor, streamHashFirmado);
        finalizarFirmaPdf(x509Certificate, signatureAppearance, streamHashFirmado.toByteArray(), streamSalida);
    }

    public void firmarEnPDFConPKCS12WebServiceParcial(ISignerWebService webService, String PKCS12Data, String PKCS12Password, String alias, String trustStoreData, String trustStorePassword, OutputStream streamSalida)
        throws TSPException, CertificateException, IOException, DocumentException, NoSuchAlgorithmException, NoSuchProviderException, GeneralSecurityException, CertStoreException, Exception
    {
        PdfSignatureAppearance signatureAppearance = iniciarFirmaPdf(null, streamSalida);
        String firmaBase64 = webService.firmarEnPKCS7ConPKCS12(PKCS12Data, PKCS12Password, alias, trustStoreData, trustStorePassword, 0L, new String(Base64Coder.encode(getSha1(signatureAppearance.getRangeStream()))));
        finalizarFirmaPdf(null, signatureAppearance, Base64Coder.decode(firmaBase64), streamSalida);
    }

    public void firmarEnPDFConPKCS12WebServiceTotal(ISignerWebService webService, String PKCS12Data, String PKCS12Password, String alias, String trustStoreData, String trustStorePassword, OutputStream streamSalida)
        throws TSPException, CertificateException, IOException, DocumentException, NoSuchAlgorithmException, NoSuchProviderException, GeneralSecurityException, CertStoreException, Exception
    {
        String firmaBase64 = webService.firmarEnPDFConPKCS12(PKCS12Data, PKCS12Password, alias, trustStoreData, trustStorePassword, 0L, new String(Base64Coder.encode(contenido)));
        streamSalida.write(Base64Coder.decode(firmaBase64));
    }

    public void firmarMasivoEnPDFConPKCS11WebServiceParcial(ISignerWebService webService, int user, OutputStream streamSalida)
        throws TSPException, CertificateException, IOException, DocumentException, NoSuchAlgorithmException, NoSuchProviderException, GeneralSecurityException, CertStoreException, Exception
    {
        PdfSignatureAppearance signatureAppearance = iniciarFirmaPdf(null, streamSalida);
        String firmaBase64 = webService.firmarEnPKCS7ConPKCS11(user, new String(Base64Coder.encode(getSha1(signatureAppearance.getRangeStream()))));
        finalizarFirmaPdf(null, signatureAppearance, Base64Coder.decode(firmaBase64), streamSalida);
    }

    public void firmarEnPDFConPKCS11WebServiceParcial(ISignerWebService webService, String pkcs11LibPath, String pkca11Password, int slot, String alias, String aliasPassword, String trustStoreData, 
            String trustStorePassword, OutputStream streamSalida)
        throws TSPException, CertificateException, IOException, DocumentException, NoSuchAlgorithmException, NoSuchProviderException, GeneralSecurityException, CertStoreException, Exception
    {
        PdfSignatureAppearance signatureAppearance = iniciarFirmaPdf(null, streamSalida);
        String firmaBase64 = webService.firmarEnPKCS7ConPKCS11(pkcs11LibPath, pkca11Password, slot, alias, aliasPassword, trustStoreData, trustStorePassword, 0L, new String(Base64Coder.encode(getSha1(signatureAppearance.getRangeStream()))));
        finalizarFirmaPdf(null, signatureAppearance, Base64Coder.decode(firmaBase64), streamSalida);
    }

    public void firmarEnPDFConPKCS11WebServiceTotal(ISignerWebService webService, String pkcs11LibPath, String pkca11Password, int slot, String alias, String aliasPassword, String trustStoreData, 
            String trustStorePassword, OutputStream streamSalida)
        throws TSPException, CertificateException, IOException, DocumentException, NoSuchAlgorithmException, NoSuchProviderException, GeneralSecurityException, CertStoreException, Exception
    {
        String firmaBase64 = webService.firmarEnPDFConPKCS11(pkcs11LibPath, pkca11Password, slot, alias, aliasPassword, trustStoreData, trustStorePassword, 0L, new String(Base64Coder.encode(contenido)));
        streamSalida.write(Base64Coder.decode(firmaBase64));
    }

    public void firmarPdf(KeyStore keyStore, String alias, String contraseF1a, Provider provedor, OutputStream streamSalida)
        throws InvalidAlgorithmParameterException, NoSuchAlgorithmException, IOException, DocumentException, CertStoreException, CMSException, Exception
    {
        if(!keyStore.containsAlias(alias))
            throw new Exception((new StringBuilder()).append("El almacen no contiene el alias: ").append(alias).toString());
        if(!keyStore.isKeyEntry(alias))
            throw new Exception((new StringBuilder()).append("El almacen no contiene una llave con alias: ").append(alias).toString());
        X509Certificate certificado = (X509Certificate)keyStore.getCertificate(alias);
        if(certificado == null)
            throw new Exception((new StringBuilder()).append("El almacen no contiene un certificado con alias: ").append(alias).toString());
        PrivateKey llavePrivada = (PrivateKey)keyStore.getKey(alias, contraseF1a == null ? null : contraseF1a.toCharArray());
        if(llavePrivada == null)
        {
            throw new Exception((new StringBuilder()).append("No se pudo recuperar la llave con alias: ").append(alias).toString());
        } else
        {
            firmarPdf(certificado, llavePrivada, provedor, streamSalida);
            return;
        }
    }

    public void firmarPdf(KeyStore keyStore, String alias, String contraseF1a, OutputStream streamSalida)
        throws InvalidAlgorithmParameterException, NoSuchAlgorithmException, IOException, DocumentException, CertStoreException, CMSException, Exception
    {
        if(keyStore == null)
            if(OSValidador.getOS() == co.com.andesscd.OSValidador.OSTYPE.WINDOWS)
            {
                keyStore = KeyStore.getInstance("Windows-MY", "SunMSCAPI");
                keyStore.load(null, null);
            } else
            {
                if(contraseF1a == null || contraseF1a.isEmpty())
                    contraseF1a = "changeit";
                keyStore = KeyStore.getInstance(KeyStore.getDefaultType());
                keyStore.load(new FileInputStream((new StringBuilder()).append(System.getProperty("java.home")).append("/lib/security/cacerts".replace('/', File.separatorChar)).toString()), contraseF1a.toCharArray());
            }
        firmarPdf(keyStore, alias, contraseF1a, keyStore.getProvider(), streamSalida);
    }

    public void firmarPdf(KeyStore keyStore, String contraseF1a, OutputStream streamSalida)
        throws InvalidAlgorithmParameterException, NoSuchAlgorithmException, IOException, DocumentException, CertStoreException, CMSException, Exception
    {
        String alias = null;
        Enumeration aliases = keyStore.aliases();
        do
        {
            if(!aliases.hasMoreElements())
                break;
            alias = (String)aliases.nextElement();
        } while(!keyStore.isKeyEntry(alias));
        if(alias == null || alias.isEmpty())
        {
            throw new Exception("No se enocntro una llave util para firma dentro del contenedor");
        } else
        {
            firmarPdf(keyStore, alias, contraseF1a, streamSalida);
            return;
        }
    }

    public void firmarPdf(ISignerWebService webService, String usuario, String password, OutputStream streamSalida)
        throws TSPException, CertificateException, IOException, DocumentException, NoSuchAlgorithmException, NoSuchProviderException, GeneralSecurityException, CertStoreException, Exception
    {
        PdfSignatureAppearance signatureAppearance = iniciarFirmaPdf(null, streamSalida);
        String firmaBase64 = webService.firmarConCertificadoCustodiado(usuario, password, new String(Base64Coder.encode(getSha1(signatureAppearance.getRangeStream()))));
        finalizarFirmaPdf(null, signatureAppearance, Base64Coder.decodeLines(firmaBase64), streamSalida);
    }

    public void firmarPdf(ISignerWebService webService, String usuario, String password, int otp, OutputStream streamSalida)
        throws TSPException, CertificateException, IOException, DocumentException, NoSuchAlgorithmException, NoSuchProviderException, GeneralSecurityException, CertStoreException, Exception
    {
        PdfSignatureAppearance signatureAppearance = iniciarFirmaPdf(null, streamSalida);
        String firmaBase64 = webService.firmarConCertificadoCustodiado(usuario, password, otp, new String(Base64Coder.encode(getSha1(signatureAppearance.getRangeStream()))));
        finalizarFirmaPdf(null, signatureAppearance, Base64Coder.decodeLines(firmaBase64), streamSalida);
    }

    public void firmarPdf(ISignerWebService webService, String usuario, String password, String tsaUser, String tsaPass, OutputStream streamSalida)
        throws TSPException, CertificateException, IOException, DocumentException, NoSuchAlgorithmException, NoSuchProviderException, GeneralSecurityException, CertStoreException, Exception
    {
        PdfSignatureAppearance signatureAppearance = iniciarFirmaPdf(null, streamSalida);
        String firmaBase64 = webService.firmarConCertificadoCustodiado(usuario, password, tsaUser, tsaPass, new String(Base64Coder.encode(getSha1(signatureAppearance.getRangeStream()))));
        finalizarFirmaPdf(null, signatureAppearance, Base64Coder.decodeLines(firmaBase64), streamSalida);
    }

    public void firmarPdf(ISignerWebService webService, String usuario, String password, int otp, String tsaUser, String tsaPass, OutputStream streamSalida)
        throws TSPException, CertificateException, IOException, DocumentException, NoSuchAlgorithmException, NoSuchProviderException, GeneralSecurityException, CertStoreException, Exception
    {
        PdfSignatureAppearance signatureAppearance = iniciarFirmaPdf(null, streamSalida);
        String firmaBase64 = webService.firmarConCertificadoCustodiado(usuario, password, otp, tsaUser, tsaPass, new String(Base64Coder.encode(getSha1(signatureAppearance.getRangeStream()))));
        finalizarFirmaPdf(null, signatureAppearance, Base64Coder.decodeLines(firmaBase64), streamSalida);
    }

    public static HashMap listarStore(KeyStore keyStore, String password)
        throws NoSuchProviderException, KeyStoreException, IOException, NoSuchAlgorithmException, CertificateException, CMSException
    {
        HashMap certificados = new HashMap();
        if(keyStore == null)
            if(OSValidador.getOS() == co.com.andesscd.OSValidador.OSTYPE.WINDOWS)
                keyStore = crearWindowsStore();
            else
                keyStore = crearJKSStore((new StringBuilder()).append(System.getProperty("java.home")).append("/lib/security/cacerts".replace('/', File.separatorChar)).toString(), password);
        Enumeration aliases = keyStore.aliases();
        do
        {
            if(!aliases.hasMoreElements())
                break;
            String alias = (String)aliases.nextElement();
            System.out.println((new StringBuilder()).append(alias).append("->").append(keyStore.isKeyEntry(alias)).append(":").append(keyStore.isCertificateEntry(alias)).toString());
            if(keyStore.isKeyEntry(alias) || keyStore.isCertificateEntry(alias))
            {
                X509Certificate cert = (X509Certificate)keyStore.getCertificate(alias);
                certificados.put(alias, cert);
            }
        } while(true);
        return certificados;
    }

    public static HashMap listarStore(KeyStore keyStore)
        throws NoSuchProviderException, KeyStoreException, IOException, NoSuchAlgorithmException, CertificateException, CMSException
    {
        return listarStore(keyStore, "changeit");
    }

    private static boolean esAutoFirmado(X509Certificate cert)
        throws CertificateException, NoSuchAlgorithmException, NoSuchProviderException
    {
        try
        {
            java.security.PublicKey key = cert.getPublicKey();
            cert.verify(key);
            return true;
        }
        catch(SignatureException sigEx)
        {
            return false;
        }
        catch(InvalidKeyException keyEx)
        {
            return false;
        }
    }

    public static RESULTADO_VERIFICACION validarCertificado(X509Certificate cert, Set trustedRootCerts, Set intermediateCerts, Date fechaDeInteres, String urlOCSP, String urlCRL)
        throws InvalidAlgorithmParameterException, NoSuchAlgorithmException, NoSuchProviderException, CertificateException, TSPException, Exception
    {
        if(esAutoFirmado(cert))
            return RESULTADO_VERIFICACION.RAIZ_NO_CONFIABLE;
        X509CertSelector selector = new X509CertSelector();
        selector.setCertificate(cert);
        Set trustAnchors = new HashSet();
        X509Certificate trustedRootCert;
        for(Iterator i$ = trustedRootCerts.iterator(); i$.hasNext(); trustAnchors.add(new TrustAnchor(trustedRootCert, null)))
            trustedRootCert = (X509Certificate)i$.next();

        PKIXBuilderParameters pkixParams;
        try
        {
            pkixParams = new PKIXBuilderParameters(trustAnchors, selector);
        }
        catch(InvalidAlgorithmParameterException ex)
        {
            return RESULTADO_VERIFICACION.CADENA_INCOMPLETA;
        }
        pkixParams.setRevocationEnabled(false);
        pkixParams.setDate(fechaDeInteres);
        CertStore intermediateCertStore = CertStore.getInstance("Collection", new CollectionCertStoreParameters(intermediateCerts), "BC");
        pkixParams.addCertStore(intermediateCertStore);
        CertPathBuilder builder = CertPathBuilder.getInstance("PKIX", "BC");
        System.out.println("Esta es la version de Mauricio");
        CertPathBuilderResult result;
        try
        {
            result = builder.build(pkixParams);
        }
        catch(CertPathBuilderException ex)
        {
            RESULTADO_VERIFICACION res = validarFecha(cert, fechaDeInteres);
            if(res != RESULTADO_VERIFICACION.VALIDO)
                return res;
            else
                return RESULTADO_VERIFICACION.CADENA_INCOMPLETA;
        }
        List certificados = result.getCertPath().getCertificates();
        X509Certificate cadenaCertificacion[] = new X509Certificate[certificados.size()];
        for(int i = 0; i < certificados.size(); i++)
            cadenaCertificacion[i] = (X509Certificate)certificados.get(i);

        RESULTADO_VERIFICACION resultado = OCSPClient.consultarOCSP(cadenaCertificacion, urlOCSP);
        if(resultado == RESULTADO_VERIFICACION.CERTIFICADO_REVOCADO)
            return resultado;
        if(resultado != RESULTADO_VERIFICACION.VALIDO)
        {
            resultado = CRLClient.consultarCRL(cert, urlCRL);
            if(resultado != RESULTADO_VERIFICACION.VALIDO)
                return resultado;
        }
        return validarFecha(cert, fechaDeInteres);
    }

    protected static RESULTADO_VERIFICACION validarFecha(X509Certificate cert, Date fechaDeInteres)
        throws CertificateException, TSPException, NoSuchAlgorithmException, Exception
    {
        try
        {
            if(fechaDeInteres == null)
                fechaDeInteres = getFechaActual().getTime();
            cert.checkValidity(fechaDeInteres);
        }
        catch(CertificateExpiredException ex)
        {
            return RESULTADO_VERIFICACION.CERTIFICADO_EXPIRADO;
        }
        catch(CertificateNotYetValidException ex)
        {
            return RESULTADO_VERIFICACION.CERTIFICADO_AUN_NO_VALIDO;
        }
        return RESULTADO_VERIFICACION.VALIDO;
    }

    public static RESULTADO_VERIFICACION validarCertificado(X509Certificate cert, Set additionalCerts, Date fechaDeInteres, String urlOCSP, String urlCRL)
        throws InvalidAlgorithmParameterException, NoSuchAlgorithmException, NoSuchProviderException, CertificateException, Exception
    {
        Set trustedRootCerts = new HashSet();
        Set intermediateCerts = new HashSet();
        if(additionalCerts != null)
        {
            for(Iterator i$ = additionalCerts.iterator(); i$.hasNext();)
            {
                X509Certificate additionalCert = (X509Certificate)i$.next();
                if(esAutoFirmado(additionalCert))
                    trustedRootCerts.add(additionalCert);
                else
                    intermediateCerts.add(additionalCert);
            }

        }
        return validarCertificado(cert, trustedRootCerts, intermediateCerts, fechaDeInteres, urlOCSP, urlCRL);
    }

    public static RESULTADO_VERIFICACION validarCertificado(X509Certificate cert, KeyStore additionalCertsStore, Date fechaDeInteres, String urlOCSP, String urlCRL)
        throws KeyStoreException, IOException, NoSuchAlgorithmException, CertificateException, InvalidAlgorithmParameterException, NoSuchProviderException, Exception
    {
        HashSet additionalCerts = new HashSet();
        if(additionalCertsStore == null)
        {
            if(OSValidador.getOS() == co.com.andesscd.OSValidador.OSTYPE.WINDOWS)
            {
                additionalCertsStore = KeyStore.getInstance("Windows-MY", "SunMSCAPI");
                additionalCertsStore.load(null, null);
                String alias = additionalCertsStore.getCertificateAlias(cert);
                if(alias == null)
                {
                    additionalCertsStore.deleteEntry("temporal");
                    additionalCertsStore.setCertificateEntry("temporal", cert);
                    additionalCertsStore.load(null, null);
                    alias = "temporal";
                }
                Certificate cadenaCertificacion[] = additionalCertsStore.getCertificateChain(alias);
                additionalCertsStore.deleteEntry("temporal");
                Certificate arr$[] = cadenaCertificacion;
                int len$ = arr$.length;
                for(int i$ = 0; i$ < len$; i$++)
                {
                    Certificate c = arr$[i$];
                    additionalCerts.add((X509Certificate)c);
                }

            } else
            {
                additionalCertsStore = KeyStore.getInstance(KeyStore.getDefaultType());
                additionalCertsStore.load(new FileInputStream((new StringBuilder()).append(System.getProperty("java.home")).append("/lib/security/cacerts".replace('/', File.separatorChar)).toString()), "changeit".toCharArray());
                Enumeration aliases = additionalCertsStore.aliases();
                do
                {
                    if(!aliases.hasMoreElements())
                        break;
                    String alias = (String)aliases.nextElement();
                    if(additionalCertsStore.isKeyEntry(alias) || additionalCertsStore.isCertificateEntry(alias))
                        additionalCerts.add((X509Certificate)additionalCertsStore.getCertificate(alias));
                } while(true);
                additionalCerts.add(cert);
            }
        } else
        {
            Enumeration aliases = additionalCertsStore.aliases();
            do
            {
                if(!aliases.hasMoreElements())
                    break;
                String alias = (String)aliases.nextElement();
                if(additionalCertsStore.isKeyEntry(alias) || additionalCertsStore.isCertificateEntry(alias))
                    additionalCerts.add((X509Certificate)additionalCertsStore.getCertificate(alias));
            } while(true);
            additionalCerts.add(cert);
        }
        return validarCertificado(cert, ((Set) (additionalCerts)), fechaDeInteres, urlOCSP, urlCRL);
    }

    public static RESULTADO_VERIFICACION validarCertificado(KeyStore keyStore, String alias, KeyStore additionalCertsStore, Date fechaDeInteres, String urlOCSP, String urlCRL)
        throws KeyStoreException, IOException, NoSuchAlgorithmException, CertificateException, InvalidAlgorithmParameterException, NoSuchProviderException, Exception
    {
        if(keyStore == null)
            if(OSValidador.getOS() == co.com.andesscd.OSValidador.OSTYPE.WINDOWS)
            {
                keyStore = KeyStore.getInstance("Windows-MY", "SunMSCAPI");
                keyStore.load(null, null);
            } else
            {
                keyStore = KeyStore.getInstance(KeyStore.getDefaultType());
                keyStore.load(new FileInputStream((new StringBuilder()).append(System.getProperty("java.home")).append("/lib/security/cacerts".replace('/', File.separatorChar)).toString()), "changeit".toCharArray());
            }
        if(alias == null)
        {
            Enumeration aliases = keyStore.aliases();
            do
            {
                if(!aliases.hasMoreElements())
                    break;
                alias = (String)aliases.nextElement();
            } while(!keyStore.isKeyEntry(alias) && !keyStore.isCertificateEntry(alias));
        }
        X509Certificate cert = (X509Certificate)keyStore.getCertificate(alias);
        if(cert == null)
            throw new Exception((new StringBuilder()).append("No existe el alias ").append(alias).append(" en el store").toString());
        else
            return validarCertificado(cert, additionalCertsStore, fechaDeInteres, urlOCSP, urlCRL);
    }

    private static boolean compararHash(byte hash1[], byte hash2[])
        throws Exception
    {
        if(hash1 == null || hash2 == null)
            throw new Exception("Uno de los hash a comprar es nulo");
        if(hash1.length == 0 || hash2.length == 0)
            throw new Exception("Uno de los hash a comprar esta vacio");
        if(hash1.length != hash2.length)
            return false;
        for(int i = 0; i < hash1.length; i++)
            if(hash1[i] != hash2[i])
                return false;

        return true;
    }

    public RESULTADO_VERIFICACION verificar(KeyStore additionalCertsStore, SignerInformation firmante, X509Certificate certificado, boolean verificarSoloIntegridad)
        throws NoSuchAlgorithmException, NoSuchProviderException, CMSException, KeyStoreException, IOException, CertificateException, OperatorCreationException, Exception
    {
        decode(null);
        JcaSimpleSignerInfoVerifierBuilder signerInfoVerifierBuilder = new JcaSimpleSignerInfoVerifierBuilder();
        if(!firmante.verify(signerInfoVerifierBuilder.build(certificado.getPublicKey())))
            return RESULTADO_VERIFICACION.DOCUMENTO_ORIGINAL_MODIFICADO;
        Date fechaFirma = null;
        Date fechaActual = null;
        Attribute atributos = null;
        try
        {
            atributos = firmante.getSignedAttributes().get(new ASN1ObjectIdentifier(ID_TIME));
        }
        catch(Exception ex) { }
        if(atributos != null)
        {
            Enumeration en = atributos.getAttrValues().getObjects();
            do
            {
                if(!en.hasMoreElements())
                    break;
                Object obj = en.nextElement();
                if(obj instanceof ASN1UTCTime)
                {
                    ASN1UTCTime asn1Time = (ASN1UTCTime)obj;
                    fechaFirma = asn1Time.getDate();
                } else
                if(obj instanceof DERUTCTime)
                {
                    DERUTCTime derTime = (DERUTCTime)obj;
                    fechaFirma = derTime.getDate();
                }
            } while(true);
        }
        atributos = null;
        try
        {
            atributos = firmante.getUnsignedAttributes().get(new ASN1ObjectIdentifier(ID_TIME_STAMP_TOKEN));
        }
        catch(Exception ex) { }
        if(atributos != null)
        {
            ASN1Encodable arr$[] = atributos.getAttributeValues();
            int len$ = arr$.length;
            int i$ = 0;
            if(i$ < len$)
            {
                ASN1Encodable encodeddata = arr$[i$];
                CMSSignedData cmsSignedData = new CMSSignedData(encodeddata.toASN1Primitive().getEncoded());
                TimeStampToken timeStampToken = new TimeStampToken(cmsSignedData);
                fechaFirma = timeStampToken.getTimeStampInfo().getGenTime();
                try
                {
                    CMS cmsToken = new CMS(new ByteArrayInputStream(encodeddata.toASN1Primitive().getEncoded()));
                    RESULTADO_VERIFICACION resultadoValidacionToken = cmsToken.verificar(additionalCertsStore, true);
                    if(resultadoValidacionToken != RESULTADO_VERIFICACION.VALIDO)
                        return RESULTADO_VERIFICACION.TIMESTAMP_NO_CONFIABLE;
                }
                catch(Exception ex)
                {
                    return RESULTADO_VERIFICACION.TIMESTAMP_ERROR_DE_VALIDACION;
                }
                String hashAlgoritmoOID = timeStampToken.getTimeStampInfo().toASN1Structure().getMessageImprint().getHashAlgorithm().getAlgorithm().getId();
                String hashAlgoritmoNombre;
                if(hashAlgoritmoOID.compareToIgnoreCase(TSPAlgorithms.SHA1.getId()) == 0)
                    hashAlgoritmoNombre = "SHA1";
                else
                if(hashAlgoritmoOID.compareToIgnoreCase(TSPAlgorithms.MD5.getId()) == 0)
                    hashAlgoritmoNombre = "MD5";
                else
                if(hashAlgoritmoOID.compareToIgnoreCase(TSPAlgorithms.SHA256.getId()) == 0)
                    hashAlgoritmoNombre = "SHA256";
                else
                if(hashAlgoritmoOID.compareToIgnoreCase(TSPAlgorithms.SHA384.getId()) == 0)
                    hashAlgoritmoNombre = "SHA384";
                else
                if(hashAlgoritmoOID.compareToIgnoreCase(TSPAlgorithms.SHA512.getId()) == 0)
                    hashAlgoritmoNombre = "SHA512";
                else
                    throw new Exception("Algoritmo timestamp no implementado");
                if(!hashParaTimeStamp.containsKey(hashAlgoritmoNombre))
                {
                    MessageDigest hashAlgoritmo = MessageDigest.getInstance(hashAlgoritmoNombre);
                    hashParaTimeStamp.put(hashAlgoritmoNombre, hashAlgoritmo.digest(salida));
                }
                if(!compararHash((byte[])hashParaTimeStamp.get(hashAlgoritmoNombre), timeStampToken.getTimeStampInfo().toASN1Structure().getMessageImprint().getHashedMessage()))
                    return RESULTADO_VERIFICACION.TIMESTAMP_NO_CORRESPONDE;
            }
        }
        if(fechaFirma == null)
            return RESULTADO_VERIFICACION.FECHA_FIRMA_DESCONOCIDA;
        fechaActual = getFechaActual().getTime();
        long segundos = TimeUnit.MILLISECONDS.toSeconds(fechaActual.getTime() - fechaFirma.getTime());
        if(segundos < 0L && Math.abs(segundos) > (long)Math.abs(toleranciaTemporal))
            return RESULTADO_VERIFICACION.FIRMADO_EN_EL_FUTURO;
        if(!verificarSoloIntegridad)
            return validarCertificado(certificado, additionalCertsStore, fechaFirma, urlOCSP, urlCRL);
        else
            return RESULTADO_VERIFICACION.VALIDO;
    }

    public RESULTADO_VERIFICACION verificar(KeyStore additionalCertsStore, SignerInformationStore firmates, CertStore certificados, boolean verificarSoloIntegridad)
        throws CertStoreException, NoSuchAlgorithmException, NoSuchProviderException, CMSException, KeyStoreException, IOException, CertificateException, Exception
    {
        for(Iterator iterador = firmates.getSigners().iterator(); iterador.hasNext();)
        {
            SignerInformation firmante = (SignerInformation)iterador.next();
            SignerId signerid = firmante.getSID();
            JcaX509CertSelectorConverter certSelectorConverter = new JcaX509CertSelectorConverter();
            X509CertificateHolderSelector certificateHolderSelector = new X509CertificateHolderSelector(signerid.getIssuer(), signerid.getSerialNumber());
            X509CertSelector signerConstraints = certSelectorConverter.getCertSelector(certificateHolderSelector);
            Collection certificadosDelFirmante = certificados.getCertificates(signerConstraints);
            if(!certificadosDelFirmante.isEmpty())
            {
                X509Certificate certificado = (X509Certificate)certificadosDelFirmante.iterator().next();
                RESULTADO_VERIFICACION resultado = verificar(additionalCertsStore, firmante, certificado, verificarSoloIntegridad);
                if(resultado != RESULTADO_VERIFICACION.VALIDO)
                    return resultado;
            } else
            {
                return RESULTADO_VERIFICACION.CERTIFICADO_NO_ENCONTRADO;
            }
        }

        return RESULTADO_VERIFICACION.VALIDO;
    }

    public RESULTADO_VERIFICACION verificar(KeyStore additionalCertsStore, boolean verificarSoloIntegridad)
        throws IOException, CMSException, CertStoreException, NoSuchAlgorithmException, NoSuchProviderException, KeyStoreException, CertificateException, GeneralSecurityException, Exception
    {
        decode(null);
        return verificar(additionalCertsStore, firmantes, certificados, verificarSoloIntegridad);
    }

    public RESULTADO_VERIFICACION verificarPdf(KeyStore additionalCertsStore)
        throws IOException, CMSException, CertStoreException, NoSuchAlgorithmException, NoSuchProviderException, KeyStoreException, CertificateException, Exception, NoSuchProviderException
    {
        RESULTADO_VERIFICACION resultado = RESULTADO_VERIFICACION.ERROR_DESCONOCIDO;
        ArrayList firmas = getFirmasPdf();
        for(int i = 0; i < firmas.size(); i++)
        {
            resultado = ((CMS)firmas.get(i)).verificar(additionalCertsStore, false);
            if(resultado != RESULTADO_VERIFICACION.VALIDO)
                return resultado;
        }

        return resultado;
    }

    public static KeyStore crearPKCS11Store(String pkcs11LibPath, String pkcs11Password, int slot)
        throws CMSException, KeyStoreException, NoSuchAlgorithmException, CertificateException, IOException
    {
        if(pkcs11LibPath == null || pkcs11LibPath.isEmpty())
            throw new CMSException("No se recibio ruta a la libreria PKCS11");
        File file = new File(pkcs11LibPath);
        if(!file.exists())
        {
            throw new CMSException("No existe la libreria PKCS11 en la ruta proporcionada");
        } else
        {
            Random random = new Random();
            String pkcs11LibConfig = (new StringBuilder()).append("name=PKCS11_").append(random.nextInt(0x77359400)).append("\nlibrary=").append(pkcs11LibPath).append("\nslot=").append(slot).append("\n").toString();
            ByteArrayInputStream pkcs11LibConfigStream = new ByteArrayInputStream(pkcs11LibConfig.getBytes());
            KeyStore keyStore = KeyStore.getInstance("PKCS11", new SunPKCS11(pkcs11LibConfigStream));
            keyStore.load(pkcs11LibConfigStream, pkcs11Password.toCharArray());
            return keyStore;
        }
    }

    public static KeyStore crearPKCS11Store(String pkcs11ConfigPath, String pkcs11Password)
        throws CMSException, KeyStoreException, NoSuchAlgorithmException, CertificateException, IOException
    {
        if(pkcs11ConfigPath == null || pkcs11ConfigPath.isEmpty())
            throw new CMSException("No se recibio ruta al archivo de configuracion PKCS11");
        File file = new File(pkcs11ConfigPath);
        if(!file.exists())
        {
            throw new CMSException("No existe el archivo de configuracion PKCS11 en la ruta proporcionada");
        } else
        {
            ByteArrayInputStream pkcs11LibConfigStream = new ByteArrayInputStream(FileUtils.readFileToByteArray(file));
            KeyStore keyStore = KeyStore.getInstance("PKCS11", new SunPKCS11(pkcs11LibConfigStream));
            keyStore.load(pkcs11LibConfigStream, pkcs11Password.toCharArray());
            return keyStore;
        }
    }

    public static KeyStore crearWindowsStore()
        throws KeyStoreException, IOException, NoSuchAlgorithmException, NoSuchProviderException, CertificateException
    {
        KeyStore keyStore = KeyStore.getInstance("Windows-MY", "SunMSCAPI");
        keyStore.load(null, null);
        return keyStore;
    }

    public static KeyStore crearJKSStore(InputStream jksStream, String jksPassword)
        throws CMSException, KeyStoreException, NoSuchAlgorithmException, CertificateException, IOException
    {
        KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());
        keyStore.load(jksStream, jksPassword.toCharArray());
        return keyStore;
    }

    public static KeyStore crearJKSStore(String jksPath, String jksPassword)
        throws CMSException, KeyStoreException, NoSuchAlgorithmException, CertificateException, IOException
    {
        if(jksPath == null || jksPath.isEmpty())
            throw new CMSException("No se recibio ruta al archivo JKS");
        File file = new File(jksPath);
        if(!file.exists())
            throw new CMSException("No existe el archivo JKS en la ruta proporcionada");
        else
            return crearJKSStore(((InputStream) (new FileInputStream(jksPath))), jksPassword);
    }

    public static KeyStore crearPKCS12Store(InputStream PCKS12Stream, String PCKS12Password)
        throws CMSException, KeyStoreException, FileNotFoundException, IOException, NoSuchAlgorithmException, CertificateException
    {
        KeyStore keyStore = KeyStore.getInstance("pkcs12");
        keyStore.load(PCKS12Stream, PCKS12Password.toCharArray());
        return keyStore;
    }

    public static KeyStore crearPKCS12Store(String PCKS12Path, String PCKS12Password)
        throws CMSException, KeyStoreException, FileNotFoundException, IOException, NoSuchAlgorithmException, CertificateException
    {
        if(PCKS12Path == null || PCKS12Path.isEmpty())
            throw new CMSException("No se recibio ruta a al archivo PKCS12");
        File file = new File(PCKS12Path);
        if(!file.exists())
            throw new CMSException("No existe el archivo PKCS12 en la ruta proporcionada");
        else
            return crearPKCS12Store(((InputStream) (new FileInputStream(PCKS12Path))), PCKS12Password);
    }

    public SignerInformationStore getFirmantes()
    {
        return firmantes;
    }

    public CertStore getCertStore()
    {
        return certificados;
    }

    private static int toleranciaTemporal = 0;
    private static final int PDF_CONTENTS_SIZE = 12000;
    private static String ID_TIME_STAMP_TOKEN = "1.2.840.113549.1.9.16.2.14";
    private static String ID_TIME = "1.2.840.113549.1.9.5";
    private static FuenteHoraria fuenteHoraria;
    private static String urlFuenteHoraria = "";
    private static String loginFuenteHoraria = "";
    private static String passwordFuenteHoraria = "";
    private static boolean bcAgregado = false;
    private static boolean secureBlackboxIniciado = false;
    private static Proxy miProxy = null;
    private static boolean firmaPdfVisible = false;
    private byte contenido[];
    private String nombreDocumento;
    private String descripcion;
    private TipoDocumento tipoDocumento;
    private CMSSignedData signedData;
    private SignerInformationStore firmantes;
    private CertStore certificados;
    private PdfReader pdfReader;
    private ArrayList firmasPdf;
    private byte salida[];
    private HashMap hashParaTimeStamp;
    private HashMap pdfMetaData;
    protected String urlOCSP;
    protected String urlCRL;

    static 
    {
        fuenteHoraria = FuenteHoraria.LOCAL;
    }
}